<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gimo: gimo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">gimo<span id="projectnumber">&#160;v0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">gimo </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2github_2workspace_2_r_e_a_d_m_e"></a> </p><div class="fragment"><div class="line">   █████████  █████ ██████   ██████    ███████   </div>
<div class="line">  ███▒▒▒▒▒███▒▒███ ▒▒██████ ██████   ███▒▒▒▒▒███ </div>
<div class="line"> ███     ▒▒▒  ▒███  ▒███▒█████▒███  ███     ▒▒███</div>
<div class="line">▒███          ▒███  ▒███▒▒███ ▒███ ▒███      ▒███</div>
<div class="line">▒███    █████ ▒███  ▒███ ▒▒▒  ▒███ ▒███      ▒███</div>
<div class="line">▒▒███  ▒▒███  ▒███  ▒███      ▒███ ▒▒███     ███ </div>
<div class="line"> ▒▒█████████  █████ █████     █████ ▒▒▒███████▒  </div>
<div class="line">  ▒▒▒▒▒▒▒▒▒  ▒▒▒▒▒ ▒▒▒▒▒     ▒▒▒▒▒    ▒▒▒▒▒▒▒   </div>
</div><!-- fragment --><p><b>G</b>eneric <b>I</b>nterchangeable <b>M</b>onadic <b>O</b>perations</p>
<hr  />
<h2><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h2>
<ul>
<li><a class="el" href="#introduction">Introduction</a><ul>
<li><a class="el" href="#genericity">Genericity</a></li>
<li><a class="el" href="#interchangeability">Interchangeability</a></li>
<li><a class="el" href="#zero-cost-abstraction">Zero Cost Abstraction</a></li>
</ul>
</li>
<li><a class="el" href="#integration">Integration</a><ul>
<li><a class="el" href="#optional-extensions">Optional Extensions</a></li>
<li><a class="el" href="#portability">Portability</a></li>
<li><a class="el" href="#cmake">CMake</a></li>
<li><a class="el" href="#single-header">Single-Header</a></li>
</ul>
</li>
</ul>
<hr  />
<p><a class="anchor" id="introduction"></a> </p>
<h2><a class="anchor" id="autotoc_md3"></a>
Introduction</h2>
<p><em>gimo</em> is a small C++20 library that provides reusable monadic operations as free functions. Although C++23 introduces monadic operations for std::optional (and std::expected) as member functions, their real-world usability is still quite limited.</p>
<p>In the following sections, I’ll explain the general idea behind <em>gimo</em>.</p>
<p><a class="anchor" id="genericity"></a> </p>
<h3><a class="anchor" id="autotoc_md4"></a>
Genericity</h3>
<p>The C++ standard library is well known for its generic algorithms, which decouple concrete container implementations from the operations performed on them. For example, there is no <code>std::vector::find</code>, because <code>std::find</code> (and, since C++20, <code>std::ranges::find</code>) already solves the problem generically.</p>
<p>There is no need to reimplement the same algorithm for each container if the actual goal is simply to perform a linear search. Doing so would only result in more code, without any real benefit.</p>
<p>This is exactly what I’d like to have for monadic operations. Therefore, gimo provides the following algorithms for all <em>nullable</em> types out of the box:</p>
<ul>
<li><code><a class="el" href="d7/de2/group___a_l_g_o_r_i_t_h_m.html#ga00f421df375b40d755beefbf0e1019c2" title="Creates a pipeline step that applies a function returning a nullable type.">gimo::and_then</a></code></li>
<li><code><a class="el" href="d7/de2/group___a_l_g_o_r_i_t_h_m.html#ga1562cdcb003130aab0cdb9e52a8069ae" title="Creates a pipeline step that handles the null/error case.">gimo::or_else</a></code></li>
<li><code><a class="el" href="d7/de2/group___a_l_g_o_r_i_t_h_m.html#ga907ef2722d7fba49c368a514c6a2f7ef" title="Creates a pipeline step that transforms the underlying value.">gimo::transform</a></code></li>
</ul>
<p>Additionally, for <em>expected-like</em> types, <em>gimo</em> offers <code><a class="el" href="d7/de2/group___a_l_g_o_r_i_t_h_m.html#ga566cac50b24d7c16fe867a7f1ce6ffcc" title="Creates a pipeline step that transforms the error of an expected-like type.">gimo::transform_error</a></code>.</p>
<p>Providing these operations as free functions also enables customization. Users can add their own algorithms where needed, without being constrained by member functions.</p>
<p><a class="anchor" id="interchangeability"></a> </p>
<h3><a class="anchor" id="autotoc_md5"></a>
Interchangeability</h3>
<p>C++ has a long history, and many codebases already use their own optional- or expected-like types. Each of these typically has to implement monadic operations on its own. Even when such operations exist, it is currently impossible to mix different vocabulary types within a single pipeline.</p>
<p><em>gimo</em> makes it possible to build pipelines that involve different closure types. Consider a case where we want to use both <a href="https://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a> and <a href="https://github.com/nonstd-lite/optional-lite">nonstd-lite/optional-lite</a> in the same pipeline. Assuming that integration for both types is in place, the following just works:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> result = <a class="code hl_function" href="d5/d89/classgimo_1_1_pipeline.html#a7d204f95db16e5b360a16091543b78d2">gimo::apply</a>(</div>
<div class="line">    std::optional{1337},</div>
<div class="line">    <a class="code hl_function" href="d7/de2/group___a_l_g_o_r_i_t_h_m.html#ga00f421df375b40d755beefbf0e1019c2">gimo::and_then</a>([](<span class="keywordtype">int</span> <span class="keyword">const</span> v) { </div>
<div class="line">        <span class="keywordflow">return</span> nonstd::optional&lt;std::string&gt;{std::to_string(v)};</div>
<div class="line">    }));</div>
<div class="ttc" id="aclassgimo_1_1_pipeline_html_a7d204f95db16e5b360a16091543b78d2"><div class="ttname"><a href="d5/d89/classgimo_1_1_pipeline.html#a7d204f95db16e5b360a16091543b78d2">gimo::Pipeline::apply</a></div><div class="ttdeci">constexpr auto apply(Nullable &amp;&amp;opt, Pipeline &amp;&amp;steps)</div><div class="ttdoc">Applies nullable input on the pipeline.</div><div class="ttdef"><b>Definition</b> Pipeline.hpp:186</div></div>
<div class="ttc" id="agroup___a_l_g_o_r_i_t_h_m_html_ga00f421df375b40d755beefbf0e1019c2"><div class="ttname"><a href="d7/de2/group___a_l_g_o_r_i_t_h_m.html#ga00f421df375b40d755beefbf0e1019c2">gimo::and_then</a></div><div class="ttdeci">constexpr auto and_then(Action &amp;&amp;action)</div><div class="ttdoc">Creates a pipeline step that applies a function returning a nullable type.</div><div class="ttdef"><b>Definition</b> AndThen.hpp:157</div></div>
</div><!-- fragment --><p>See the full example on <a href="https://godbolt.org/z/ETWxbnhce">godbolt.org</a>.</p>
<p><a class="anchor" id="zero-cost-abstraction"></a> </p>
<h3><a class="anchor" id="autotoc_md6"></a>
Zero Cost Abstraction</h3>
<p>This section describes more of a nice side effect, but it’s something I like to point out in discussions, because it supports the idea that monadic operations should be free functions.</p>
<p>Consider the following snippet, where several transform operations are composed in a single pipeline: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span> result = std::optional{1337}</div>
<div class="line">    .transform([](<span class="keywordtype">int</span> <span class="keyword">const</span> v) { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(v); })</div>
<div class="line">    .<a class="code hl_function" href="d7/de2/group___a_l_g_o_r_i_t_h_m.html#ga907ef2722d7fba49c368a514c6a2f7ef">transform</a>([](<span class="keywordtype">float</span> <span class="keyword">const</span> v) { <span class="keywordflow">return</span> std::to_string(v); });</div>
<div class="ttc" id="agroup___a_l_g_o_r_i_t_h_m_html_ga907ef2722d7fba49c368a514c6a2f7ef"><div class="ttname"><a href="d7/de2/group___a_l_g_o_r_i_t_h_m.html#ga907ef2722d7fba49c368a514c6a2f7ef">gimo::transform</a></div><div class="ttdeci">constexpr auto transform(Action &amp;&amp;action)</div><div class="ttdoc">Creates a pipeline step that transforms the underlying value.</div><div class="ttdef"><b>Definition</b> Transform.hpp:162</div></div>
</div><!-- fragment --><p>The final result is not particularly surprising. However, if we look a bit closer at what happens under the hood, some inefficiencies become apparent.</p>
<p>We start with a non-empty <code>std::optional</code> and call transform. This operation checks whether the optional contains a value and then applies the function. The second transform has to perform the same emptiness check again, even though the first transform can never change that invariant. Each operation is fully isolated, and no information is propagated between them.</p>
<p>Now let’s look at the same example using gimo: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span> result = <a class="code hl_function" href="d5/d89/classgimo_1_1_pipeline.html#a7d204f95db16e5b360a16091543b78d2">gimo::apply</a>(</div>
<div class="line">    std::optional{1337},</div>
<div class="line">    <a class="code hl_function" href="d7/de2/group___a_l_g_o_r_i_t_h_m.html#ga907ef2722d7fba49c368a514c6a2f7ef">gimo::transform</a>([](<span class="keywordtype">int</span> <span class="keyword">const</span> v) { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(v); })</div>
<div class="line">    | <a class="code hl_function" href="d7/de2/group___a_l_g_o_r_i_t_h_m.html#ga907ef2722d7fba49c368a514c6a2f7ef">gimo::transform</a>([](<span class="keywordtype">float</span> <span class="keyword">const</span> v) { <span class="keywordflow">return</span> std::to_string(v); }));</div>
</div><!-- fragment --><p>Here, the first <code>transform</code> still needs to evaluate emptiness. However, once that information is known, it can be forwarded to the next operation.</p>
<p>In fact, this closely resembles the following rewritten code, which users may have in mind when constructing the pipeline.</p>
<div class="fragment"><div class="line">std::optional opt{1337};</div>
<div class="line"><span class="keywordflow">if</span> (opt)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> f = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(*opt);</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(f);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">return</span> std::nullopt;</div>
</div><!-- fragment --><p>Note that these optimizations depend on the specific algorithm, as each has different semantic properties. For instance, <code>or_else</code> preserves the emptiness state when the nullable holds a value, allowing this information to be propagated. Since the fallback action is not guaranteed to produce a non-empty nullable, the next operation must still perform its own check.</p>
<p><a class="anchor" id="integration"></a></p>
<h2><a class="anchor" id="autotoc_md7"></a>
Integration</h2>
<p><em>gimo</em> is a header-only library, allowing users to easily access all features by simply including the <code><a class="el" href="d4/d5a/gimo_8hpp.html">gimo.hpp</a></code> header.</p>
<p><a class="anchor" id="optional-extensions"></a></p>
<h3><a class="anchor" id="autotoc_md8"></a>
Optional Extensions</h3>
<p>The <em>gimo</em> core is a type-agnostic framework for free-standing monadic operations. Support for specific types is available via an opt-in model through the <code>gimo_ext</code> directory. These headers provide the necessary trait specializations to adapt existing types to the gimo pipeline. For instance, to enable support for <code>std::optional</code>, simply include the corresponding adapter:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="d7/da7/_std_optional_8hpp.html">gimo_ext/StdOptional.hpp</a>&gt;</span></div>
<div class="ttc" id="a_std_optional_8hpp_html"><div class="ttname"><a href="d7/da7/_std_optional_8hpp.html">StdOptional.hpp</a></div></div>
</div><!-- fragment --><p>Currently, the following extensions are provided:</p>
<ul>
<li><a href="https://github.com/DNKpp/gimo/blob/main/include/gimo_ext/StdOptional.hpp">std::optional</a></li>
<li><a href="https://github.com/DNKpp/gimo/blob/main/include/gimo_ext/StdExpected.hpp">std::expected</a></li>
<li><a href="https://github.com/DNKpp/gimo/blob/main/include/gimo_ext/RawPointer.hpp">raw-pointers</a></li>
<li><a href="https://github.com/DNKpp/gimo/blob/main/include/gimo_ext/StdUniquePtr.hpp">std::unique_ptr</a></li>
<li><a href="https://github.com/DNKpp/gimo/blob/main/include/gimo_ext/StdSharedPtr.hpp">std::shared_ptr</a></li>
</ul>
<p><a class="anchor" id="portability"></a></p>
<h3><a class="anchor" id="autotoc_md9"></a>
Portability</h3>
<p>The <em>gimo</em> framework is architected for broad compatibility with any C++20-conforming compiler, maintaining strict independence from underlying hardware architectures or operating systems. The library has been verified across various environments, including Windows, macOS, and major Linux distributions (Ubuntu, Debian) on both <code>x86_64</code> and <code>x86_32</code> platforms.</p>
<h4><a class="anchor" id="autotoc_md10"></a>
Minimum Toolchain Requirements</h4>
<p>The library is verified to work with the following compiler versions. While older versions supporting C++20 may work, these represent the minimums confirmed by the current test suite:</p>
<ul>
<li><b>GCC:</b> 10.2+</li>
<li><b>Clang:</b> 16+</li>
<li><b>MSVC:</b> v143+ (Visual Studio 2022)</li>
</ul>
<p><a class="anchor" id="cmake"></a></p>
<h3><a class="anchor" id="autotoc_md11"></a>
CMake</h3>
<p>The integration into a CMake project is straight-forward.</p>
<div class="fragment"><div class="line">target_link_libraries(&lt;your_target_name&gt; PUBLIC gimo::gimo)</div>
</div><!-- fragment --><p>Users can either select a commit in the <b>main</b> branch or a version tag and utilize the CMake <code>FetchContent</code> module:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(gimo</div>
<div class="line">    VERSION 0.1.0 # or GIT_TAG &lt;commit_hash&gt; </div>
<div class="line">    GIT_REPOSITORY https://github.com/DNKpp/gimo</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(gimo)</div>
<div class="line"># do not forget linking via target_link_libraries as shown above</div>
</div><!-- fragment --><p>As an alternative, I recommend using <a href="https://github.com/cpm-cmake/CPM.cmake">CPM</a>, which is a convenient wrapper based on the <code>FetchContent</code> feature:</p>
<div class="fragment"><div class="line">include(CPM.cmake) # or include(get_cpm.cmake)</div>
<div class="line"> </div>
<div class="line">CPMAddPackage(&quot;gh:DNKpp/gimo@0.1.0&quot;) # or gh:DNKpp/gimo#&lt;commit_hash&gt;</div>
<div class="line"># do not forget linking via target_link_libraries as shown above</div>
</div><!-- fragment --><p><a class="anchor" id="single-header"></a></p>
<h3><a class="anchor" id="autotoc_md12"></a>
Single-Header</h3>
<p>For convenience, an amalgamated version is available via <a href="https://github.com/DNKpp/gimo/blob/amalgamate/gimo-amalgamate.hpp">gimo-amalgamate.hpp</a>. This file tracks the current state of the main branch as a single, self-contained header. Please note that extensions found in <code>gimo_ext</code> are excluded from this file and must be included separately. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Dec 22 2025 for gimo by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
